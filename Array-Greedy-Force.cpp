Let's consider some array A. The following algorithm calculates it's force:

    Find all the continuous blocks where all the elemens of A are equal.
    Calculate sum of squared lengths of these blocks.

For example if array A = {2, 3, 3, 1, 1, 1, 4, 2, 2} its force will be 12 + 22 + 32 + 12 + 22 = 19

We can reorder some elements and get array with greater force. In the example above we can move the first element of A to the end and get array A = {3, 3, 1, 1, 1, 4, 2, 2, 2} with force 22 + 32 + 12 + 32 = 23.

You are given an array. What is the maximum force you can get by reordering some of its elements?

Input
The first line contains integer T denoting the number of test cases. The following T lines contain 4 integers each: A[0], A[1], N, MOD.

Array A of N elements is generated by the following way:

    A[0], A[1] are given
    A[i] = (A[i - 1] + A[i - 2]) modulo MOD for 1 < i < N.

Output
For each test case output one integer on the separate line - answer for the question.

Constraints

    1 <= T <=100
    0 <= A[0], A[1] <= 10^6
    2 <= N <= 10^6
    max(A[0] , A[1]) < MOD < 10^6

SAMPLE INPUT

2
0 1 6 4
1 1 4 2

SAMPLE OUTPUT

12
10

Explanation

Test case 1: array A = {0, 1, 1, 2, 3, 1}. The greatest possible force will be with the reordering {2, 0, 1, 1, 1, 3}

Test case 2: array A = {1, 1, 0, 1}. The greatest possible force will be with the reordering {1, 1, 1, 0}

#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t,i,q,l,k,j,h,u,sum=0,count=1;
    cin>>t;
    for(i=0; i<t; i++)
    {
    cin>>l>>k>>j>>h;
    int s[j+1];
    s[0]=l;
    s[1]=k;
    for(q=2; q<j; q++)
    {
        s[q] = (s[q-1] + s[q-2])%h;
    }
    sort(s,s+j);
    for(q=0; q<j; q++)
    {
        for(u=q+1; u<j; u++)
        {
            if(s[u]==s[q])
            {
                count++;
            }
            else
            {
                break;
            }
        }
        sum = sum + pow(count , 2);
        q = count+q-1;
        count=1;
    }
    cout<<sum<<endl;
    sum=0;
    }
}